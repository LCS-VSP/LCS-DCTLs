__CONSTANT__ float pie = 3.14159265358979323f;

//YCH Roundtrip, based on Scott Dyer article about LMT's

__DEVICE__ float3 rgb_ych(float3 in)
{
float y = in.x * .333f + in.y * .333f + in.z * .333f;
float a = in.x * .5f - in.y * .25f - in.z * .25f;
float b = in.x * 0.0f + in.y * .433f - in.z * .433f;
float c = _hypotf(a, b);
float h = (180/pie) * _atan2f(b, a);
if (h < 0.0f) h += 360.0f;
return make_float3(y, c, h);
}
__DEVICE__ float3 ych_rgb(float3 in)
{
float a = in.y * _cosf(in.z * (pie / 180.0f));
float b = in.y * _sinf(in.z * (pie / 180.0f));
float r = in.x + a * 1.333f + b * 0.0;
float g = in.x - a * .666f + b * 1.154f;
float e = in.x - a * .666f - b * 1.154f;
return make_float3(r, g, e);
}

//HSV RoundTrip, Paul Dore's formula

__DEVICE__ float3 rgb_hsv(float3 in){
float3 HSV;
float min = _fminf(_fminf(in.x, in.y), in.z);
float max = _fmaxf(_fmaxf(in.x, in.y), in.z);
HSV.z = max;
float delta = max - min;
if (max != 0.0f) {
HSV.y = delta / max;
} else {
HSV.y = 0.0f;
HSV.x = 0.0f;
return HSV;
}
if (delta == 0.0f) {
HSV.x = 0.0f;
} else if (in.x == max) {
HSV.x = (in.y - in.z) / delta;
} else if (in.y == max) {
HSV.x = 2.0f + (in.z - in.x) / delta;
} else {
HSV.x = 4.0f + (in.x - in.y) / delta;
}
HSV.x *= 1.0f / 6.0f;
if (HSV.x < 0.0f)
HSV.x += 1.0f;
return HSV;
}
__DEVICE__ float3 hsv_rgb(float3 in){
float3 RGB;
if (in.y == 0.0f) {
RGB.x = RGB.y = RGB.z = in.z;
} else {
in.x *= 6.0f;
float i = _floorf(in.x);
float f = in.x - i;
i = i >= 0.0f ? _fmod(i, 6.0f) : _fmod(i, 6.0f) + 6.0f;
float p = in.z * (1.0f - in.y);
float q = in.z * (1.0f - in.y * f);
float t = in.z * (1.0f - in.y * (1.0f - f));
RGB.x = i == 0.0f ? in.z : i == 1.0f ? q : i == 2.0f ? p : i == 3.0f ? p : i == 4.0f ? t : in.z;
RGB.y = i == 0.0f ? t : i == 1 ? in.z : i == 2.0f ? in.z : i == 3.0f ? q : i == 4.0f ? p : p;
RGB.z = i == 0.0f ? p : i == 1 ? p : i == 2.0f ? t : i == 3.0f ? in.z : i == 4.0f ? in.z : q;
}
return RGB;
}

//Cone Coordenates Roundtrip, Juan Pablo Zambrano's Formula

__DEVICE__ float3 rgb_cone(float3 rgb) {
    const float pi= 3.14159265359f;
    const float rtr = rgb.x * 0.81649658f + rgb.y * -0.40824829f + rgb.z * -0.40824829f;
    const float rtg = rgb.x * 0.0f + rgb.y * 0.70710678f + rgb.z * -0.70710678f;
    const float rtb = rgb.x * 0.57735027f + rgb.y * 0.57735027f + rgb.z * 0.57735027f;

    const float art = _atan2f(rtg, rtr);

    const float sphr = _sqrtf(rtr*rtr + rtg*rtg + rtb*rtb);
    const float spht = art < 0.0f ? art + 2.0f * 3.141592653589f : art;
    const float sphp = _atan2f(_sqrtf(rtr*rtr + rtg*rtg), rtb);

//This is to modify the lum component which is the main reason why the saturation component has a different behavior 
    const float huecoef1= 1.0f/(2.0f-(0.78539816f/0.61547971f));
    const float huecoef2 = 2.0f*sphp*_sinf((2.0f*pi/3.0f)-_fmod(spht,(pi/3.0f)))/1.7320508075688f;
    const float huemag =((_acosf(_cosf(3.0f*spht+pi)))/(pi*huecoef1)+(((0.78539816f/0.61547971f))-1.0f))*huecoef2;
    const float satmag = _sinf(huemag+0.61547971f);
    return make_float3(
        sphr*satmag,
        spht * 0.15915494309189535f,
        sphp * 1.0467733744265997f
    );
}

__DEVICE__ float3 cone_rgb(float3 sph) {
    
    const float pi= 3.14159265359f;
    sph.y *= 6.283185307179586f;
    sph.z *= 0.9553166181245093f;
    const float huecoef1= 1.0f/(2.0f-(0.78539816f/0.61547971f));
    const float huecoef2 = 2.0f*sph.z*_sinf((2.0f*pi/3.0f)- _fmod(sph.y,(pi/3.0f)))/1.7320508075688f;
    const float huemag =((_acosf(_cosf(3.0f*sph.y+pi)))/(pi*huecoef1)+(((0.78539816f/0.61547971f))-1.0f))*huecoef2;
    const float satmagsp = _sinf(huemag+0.61547971f);
    sph.x *= 1.0f/satmagsp;

    const float ctr = sph.x * _sinf(sph.z) * _cosf(sph.y);
    const float ctg = sph.x * _sinf(sph.z) * _sinf(sph.y);
    const float ctb = sph.x * _cosf(sph.z);

    return make_float3(
        ctr * 0.81649658f + ctg * 0.0f + ctb * 0.57735027f,
        ctr * -0.40824829f + ctg * 0.70710678f + ctb * 0.57735027f,
        ctr * -0.40824829f + ctg * -0.70710678f + ctb * 0.57735027f
    );
}

//Funções
__DEVICE__ float apply_sat(float in, float sat)
{
float out;
out =(0 * _powf(1 - in,3) + 3 * sat * _powf(1 - in,2) * in + 3 * (sat+.333f) * (1 - in) * _powf(in,2) + 1.0 * _powf(in,3)) * 1;
return out;
}
__DEVICE__ float apply_sat_gain(float in, float gain)
{
float out;
out=in*gain;
return out;
}
__DEVICE__ float apply_limit(float in, float limit_out, float threshold)
{
float out;
if(in>=threshold){
float a = (limit_out - threshold)/(1.0f - threshold);
float b =_powf(a,-1.0f) - 1.0f;
float s = (1.0f - threshold) / _powf(b,1.0f);
float c = 1.0f + ((in - threshold) / s);
float d = _powf(c,1.0f);
out = threshold + s *((in - threshold) / s) / _powf(d,1.0f);
}
else{
out=in;
}
return out;
}


DEFINE_UI_PARAMS(gain, Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(boost, Color Boost, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(threshold, Threshold, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(limit_out, Compression, DCTLUI_SLIDER_FLOAT, 1.0, 0.001, 1.0, 0.001)
DEFINE_UI_PARAMS(model, Color Model, DCTLUI_COMBO_BOX, 0, { hsv, ych, cone }, { HSV, YCH, Cone Coordenates})


__DEVICE__ float3 transform (int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float3 in = {p_R, p_G, p_B};

    float3 out;
    float sat = boost*.333;
    limit_out = limit_out*.999f;
//HSV
    if(model==hsv){
    {
    out=rgb_hsv(in);
    }
    {
    out.x=out.x;
    out.y=apply_sat(out.y, sat);
    out.z=out.z;
    }
    {
    out.x=out.x;
    out.y=apply_sat_gain(out.y, gain);
    out.z=out.z;
    }
    {
    out.x = out.x;
    out.y = apply_limit(out.y, limit_out, threshold);
    out.z = out.z;
    }
    {
    out = hsv_rgb(out);
    }
    }
//YCH
    if(model==ych){
    {
    out=rgb_ych(in);
    }
    {
    out.x=out.x;
    out.y=apply_sat(out.y, sat);
    out.z=out.z;
    }
    {
    out.x=out.x;
    out.y=apply_sat_gain(out.y, gain);
    out.z=out.z;
    }
    {
    out.x = out.x;
    out.y = apply_limit(out.y, limit_out, threshold);
    out.z = out.z;
    }
    {
    out = ych_rgb(out);
    }
    }
//Cone Coordenates
    if(model==cone){
    {
    out=rgb_cone(in);
    }
    {
    out.x=out.x;
    out.y=out.y;
    out.z=apply_sat(out.z, sat);
    }
    {
    out.x=out.x;
    out.y=out.y;
    out.z=apply_sat_gain(out.z, gain);
    }
    {
    out.x = out.x;
    out.y = out.y;
    out.z = apply_limit(out.z, limit_out, threshold);
    }
    {
    out = cone_rgb(out);
    }
    }
    return out;
}

